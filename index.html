<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Credential-type SSO Extension – Complete Web Tester</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --mono:#111; --muted:#666; --bg:#f7f7f9; --bd:#e5e5ea; }
    body { font: 14px/1.45 -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; color:#111; }
    h1 { font-size: 20px; margin: 0 0 8px; }
    p.muted { color: var(--muted); margin-top: 4px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 12px;}
    .row { margin: 10px 0; }
    label { font-weight: 600; display:block; margin: 6px 0; }
    input[type=text] { width: 100%; padding: 8px 10px; border:1px solid var(--bd); border-radius: 8px; }
    .btns button { padding: 8px 12px; border:1px solid var(--bd); background:#fff; border-radius: 8px; cursor:pointer; }
    .btns button+button { margin-left: 8px; }
    pre { background: var(--bg); border:1px solid var(--bd); padding: 12px; border-radius: 8px; overflow:auto; white-space: pre-wrap; word-break: break-word; }
    code { background: var(--bg); padding: 2px 4px; border:1px solid var(--bd); border-radius: 6px;}
    .hint { font-size: 12px; color: var(--muted); margin-top: 6px; }
    .ok { color: #0a7; }
    .err { color: #b00; }
  </style>
</head>
<body>
  <h1>Credential-type SSO Extension – Complete Web Tester</h1>
  <p class="muted">
    This page issues normal HTTP requests to your associated host. Safari should route them to your credential-type SSO extension.
    No redirects are used. Use the buttons below to try different patterns and see detailed results.
  </p>

  <div class="row">
    <label>Endpoint (under your associated host):</label>
    <input id="endpoint" type="text" value="https://apps.pingone.com/pingid/desktop/status" />
    <div class="hint">Use a stable path your extension handles (e.g., <code>/status</code> or <code>/handshake</code>). Host must be exactly <code>apps.pingone.com</code>.</div>
  </div>

  <div class="grid">
    <div>
      <label>Origin to allow (for CORS hints):</label>
      <input id="origin" type="text" />
      <div class="hint">If your extension enforces CORS, set this to your site’s origin (e.g., <code>https://yourapp.example.com</code>).</div>
    </div>
    <div>
      <label>Expected JSON keys (comma-separated):</label>
      <input id="expect" type="text" value="device_sig,device_key_id,jwt,state" />
    </div>
  </div>

  <div class="row btns">
    <button id="probeGet">GET (no preflight)</button>
    <button id="postPlain">POST text/plain (no preflight)</button>
    <button id="postJSON">POST application/json (preflight)</button>
    <button id="preflight">OPTIONS (preflight only)</button>
    <button id="clear">Clear</button>
  </div>

  <div class="grid">
    <div>
      <h3>Request</h3>
      <pre id="req">(none)</pre>
    </div>
    <div>
      <h3>Response</h3>
      <pre id="res">(none)</pre>
    </div>
  </div>

  <script>
    // --- utils ---
    function b64urlFromBytes(bytes) {
      let s = ""; for (let i = 0; i < bytes.length; i++) s += String.fromCharCode(bytes[i]);
      return btoa(s).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/,"");
    }
    function randB64url(n = 32) { const b = new Uint8Array(n); crypto.getRandomValues(b); return b64urlFromBytes(b); }
    function now() { return (performance.now() / 1000).toFixed(3) + "s"; }
    function setPre(id, v) { document.getElementById(id).textContent = typeof v === "string" ? v : JSON.stringify(v, null, 2); }
    function getVal(id) { return document.getElementById(id).value.trim(); }
    function buildChallenge() {
      const payload = { ver: 1, ts: Date.now(), nonce: randB64url(16) };
      const raw = new TextEncoder().encode(JSON.stringify(payload));
      return { payload, chal: b64urlFromBytes(raw) };
    }
    function summarizeResponse(r, text) {
      const headers = Object.fromEntries(r.headers.entries());
      let data;
      try { data = JSON.parse(text); } catch { data = text; }
      return { status: r.status, statusText: r.statusText, headers, body: data };
    }
    function expectedMissing(obj, keysCSV) {
      const keys = keysCSV.split(",").map(s => s.trim()).filter(Boolean);
      if (!keys.length || typeof obj !== "object" || obj === null) return [];
      return keys.filter(k => !(k in obj));
    }
    function toQuery(obj) {
      const u = new URLSearchParams();
      for (const [k,v] of Object.entries(obj)) u.set(k, v);
      return u.toString();
    }

    // --- main actions ---
    async function doGet() {
      const url = new URL(getVal("endpoint"));
      const { payload, chal } = buildChallenge();
      url.searchParams.set("device_chal", chal);
      url.searchParams.set("state", randB64url(8));

      const req = { method: "GET", url: url.toString() };
      setPre("req", req);

      const t0 = performance.now();
      try {
        const r = await fetch(url.toString(), { method: "GET" });
        const txt = await r.text();
        const out = summarizeResponse(r, txt);
        out.timing = { started: now(), elapsed_ms: Math.round(performance.now() - t0) };
        setPre("res", out);
        const miss = expectedMissing(out.body, getVal("expect"));
        if (miss.length) console.warn("Missing keys:", miss);
      } catch (e) {
        setPre("res", { error: String(e), started: now(), endpoint: url.toString() });
      }
    }

    async function doPostPlain() {
      const url = getVal("endpoint");
      const { payload, chal } = buildChallenge();
      const body = JSON.stringify({ device_chal: chal, state: randB64url(8) });

      const req = { method: "POST", url, headers: { "Content-Type": "text/plain;charset=UTF-8" }, body: JSON.parse(body) };
      setPre("req", req);

      const t0 = performance.now();
      try {
        const r = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "text/plain;charset=UTF-8" }, // simple → no preflight
          body
        });
        const txt = await r.text();
        const out = summarizeResponse(r, txt);
        out.timing = { started: now(), elapsed_ms: Math.round(performance.now() - t0) };
        setPre("res", out);
        const miss = expectedMissing(out.body, getVal("expect"));
        if (miss.length) console.warn("Missing keys:", miss);
      } catch (e) {
        setPre("res", { error: String(e), started: now(), endpoint: url });
      }
    }

    async function doPostJSON() {
      const url = getVal("endpoint");
      const { payload, chal } = buildChallenge();
      const body = { device_chal: chal, state: randB64url(8) };

      const req = { method: "POST", url, headers: { "Content-Type": "application/json" }, body };
      setPre("req", req);

      const t0 = performance.now();
      try {
        const r = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" }, // → preflight
          body: JSON.stringify(body),
          // If your extension sets Set-Cookie and you need them:
          // credentials: "include"
        });
        const txt = await r.text();
        const out = summarizeResponse(r, txt);
        out.timing = { started: now(), elapsed_ms: Math.round(performance.now() - t0) };
        setPre("res", out);
        const miss = expectedMissing(out.body, getVal("expect"));
        if (miss.length) console.warn("Missing keys:", miss);
      } catch (e) {
        setPre("res", { error: String(e), started: now(), endpoint: url });
      }
    }

    async function doPreflight() {
      const url = getVal("endpoint");
      const origin = getVal("origin") || window.location.origin;

      // Manual OPTIONS preflight (simulates what the browser sends)
      const req = {
        method: "OPTIONS",
        url,
        headers: {
          "Origin": origin,
          "Access-Control-Request-Method": "POST",
          "Access-Control-Request-Headers": "content-type,authorization"
        }
      };
      setPre("req", req);

      const t0 = performance.now();
      try {
        const r = await fetch(url, {
          method: "OPTIONS",
          headers: {
            "Origin": origin,
            "Access-Control-Request-Method": "POST",
            "Access-Control-Request-Headers": "content-type,authorization"
          }
        });
        const txt = await r.text();
        const out = summarizeResponse(r, txt);
        out.timing = { started: now(), elapsed_ms: Math.round(performance.now() - t0) };
        setPre("res", out);
      } catch (e) {
        setPre("res", { error: String(e), started: now(), endpoint: url });
      }
    }

    // --- wire up ---
    document.getElementById("origin").value = window.location.origin;
    document.getElementById("probeGet").addEventListener("click", doGet);
    document.getElementById("postPlain").addEventListener("click", doPostPlain);
    document.getElementById("postJSON").addEventListener("click", doPostJSON);
    document.getElementById("preflight").addEventListener("click", doPreflight);
    document.getElementById("clear").addEventListener("click", () => { setPre("req","(none)"); setPre("res","(none)"); });
  </script>
</body>
</html>
